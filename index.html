<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Demo</title>

<style>
/* body {
  font-family: Monospace;
  background: #999;
  color: #fff;
  margin: 0px;
  overflow-x: hidden;
} */
</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r124/three.min.js"></script>
<script src="https://unpkg.com/three@0.126.0/examples/js/loaders/GLTFLoader.js"></script>
<script src="https://unpkg.com/three@0.126.0/examples/js/loaders/DRACOLoader.js"></script>
<script src="https://unpkg.co/gsap@3/dist/gsap.min.js"></script>
<script src="https://unpkg.com/gsap@3/dist/ScrollTrigger.min.js"></script>
</head>
<body>
    


<script>
   

//===================================================== canvas
var renderer = new THREE.WebGLRenderer({ alpha: true, antialiase: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

//===================================================== scene
var scene = new THREE.Scene();

//===================================================== camera
var camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.01,
  1000
);
camera.position.z = 5;
camera.position.y = 1.5;
camera.position.x = 0.05;

//===================================================== lights
var light = new THREE.AmbientLight(0xefefff, 1);
light.position.set(1, 1, 1).normalize();
scene.add(light);
var light = new THREE.AmbientLight(0xffefef, 1);
light.position.set(-1, -1, -1).normalize();
scene.add(light);

//===================================================== resize
window.addEventListener("resize", function () {
  let width = window.innerWidth;
  let height = window.innerHeight;
  renderer.setSize(width, height);
  camera.aspect = width / height;
  camera.updateProjectionMatrix();
});

const dracoLoader = new THREE.DRACOLoader();
dracoLoader.setDecoderPath('/draco/');

var loader = new THREE.GLTFLoader();
loader.setDRACOLoader(dracoLoader);
var mixer;
var model;
var animationtime = false;
loader.load(
  "morph.glb",
  function (gltf) {
    gltf.scene.traverse(function (node) {
      if (node instanceof THREE.Mesh) {
        node.castShadow = true;
        node.material.side = THREE.DoubleSide;
      }
    });

    model = gltf.scene;
    model.scale.set(29, 29, 29);
    scene.add(model);

    mixer = new THREE.AnimationMixer(model);
    var action = mixer.clipAction(gltf.animations[0]);
    action.play();
    createAnimation(mixer, action, gltf.animations[0]);
  }
);

var clock = new THREE.Clock();
function render() {
  requestAnimationFrame(render);
  var delta = clock.getDelta();
  if (mixer != null) mixer.update(delta);

  renderer.render(scene, camera);
}

render();
gsap.registerPlugin(ScrollTrigger);

function createAnimation(mixer, action, clip) {
  let proxy = {
    get time() {
      return mixer.time;
    },
    set time(value) {
      
      if(!animationtime) animationtime = value;

      let percet = value/animationtime;
      if(percet > 1) percet = 0;
      percet = 1 - percet;


      let roto = percet * Math.PI;
      model.rotation.y = roto;

      let poso = percet;
      if( poso < 0.44){
        poso -= 0.22;
        poso = Math.abs(poso);

        poso *= 10;
        poso -= 2.2;
      }
      else{
        poso = 0;
      }
      model.position.x = poso;



      let posoy = percet;
      if( posoy <= 0.34){
        posoy -= 0.34;
        posoy = Math.abs(posoy);
        posoy *= 2.3;

      }
      else{
        posoy = 0;
      }
      model.position.y = posoy;

      action.paused = false;
      mixer.setTime(value);
      action.paused = true;
    }
  };

  let scrollingTL = gsap.timeline({
    scrollTrigger: {
      trigger: renderer.domElement,
      start: "top top",
      end: "+=900%",
      pin: true,
      scrub: true,
      markers: false,
      onUpdate: function () {
        camera.updateProjectionMatrix();
      }
    }
  });

  scrollingTL.to(proxy, {
    time: clip.duration-0.01,
    repeat: 0,
  });
}

</script>


</body>
</html>